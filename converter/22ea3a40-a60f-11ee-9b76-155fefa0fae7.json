{
  "entityType" : "CONVERTER",
  "entity" : {
    "additionalInfo" : {
      "description" : ""
    },
    "configuration" : {
      "scriptLang" : "JS",
      "decoder" : "var data = decodeToJson(payload);\r\nvar deviceName = data.end_device_ids.device_id;\r\nvar deviceType = 'default';\r\nvar decodedPayload = data.uplink_message.decoded_payload.messages[0][0]; // Adjusted to match the structure of your provided JSON\r\nvar device_id = data.end_device_ids;\r\ndecodedPayload.device_id = device_id.device_id;\r\ndecodedPayload.hotspot_name = data.uplink_message.rx_metadata[0].gateway_ids.gateway_id;\r\ndecodedPayload.hotspot_lat = data.uplink_message.rx_metadata[0].location.latitude;\r\ndecodedPayload.hotspot_long = data.uplink_message.rx_metadata[0].location.longitude;\r\ndecodedPayload.hotspot_freq = data.uplink_message.settings.frequency;\r\n\r\nvar result = {\r\n    deviceName: deviceName,\r\n    deviceType: deviceType,\r\n    telemetry: decodedPayload\r\n};\r\n\r\nfunction decodeToString(payload) {\r\n    return String.fromCharCode.apply(String, payload);\r\n}\r\n\r\nfunction decodeToJson(payload) {\r\n    var str = decodeToString(payload);\r\n    var data = JSON.parse(str);\r\n    return data;\r\n}\r\n\r\nreturn result;",
      "tbelDecoder" : "var data = decodeToJson(payload);\n\nvar deviceName = data.end_device_ids.device_id;\nvar deviceType = data.end_device_ids.application_ids.application_id;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodeFrmPayload(input) {\n    var output = { attributes:{}, telemetry: {}};\n    // --- Decoding code --- //\n\n    output.telemetry.HEX_bytes = bytesToHex(input);\n\n    // If the length of the input byte array is odd - we cannot parse it using the example below\n    if (input.length > 0 && input.length % 2 == 0) {\n        for (var i = 0; i < input.length; ) {\n            var channel_id = input[i++];\n            var channel_type = input[i++];\n            // BATTERY\n            if (channel_id === 0x01 && channel_type === 0x75) {\n                output.telemetry.battery = input[i];\n                i += 1;\n            }\n            // PIR\n            else if (channel_id === 0x03 && channel_type === 0x00) {\n                output.telemetry.pir = input[i] === 0 ? \"normal\" : \"trigger\";\n                i += 1;\n            }\n            // DAYLIGHT\n            else if (channel_id === 0x04 && channel_type === 0x00) {\n                output.telemetry.daylight = input[i] === 0 ? \"dark\" : \"light\";\n                i += 1;\n            }\n        }\n    }\n\n    // --- Decoding code --- //\n    return output;\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.uplink_message.received_at;\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\nif ((data.simulated != null && data.simulated) || dateString == null) {\n    dateString = data.received_at;\n}\nvar timestamp = new Date(dateString).getTime();\nvar timestamp = -1;\nif (dateString != null) {\n  timestamp = new Date(dateString).getTime();\n  if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n          if (dateString.length >= secondsSeparatorIndex + 3) {\n              dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n          }\n      } else {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n              dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n  }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.devEui = data.end_device_ids.dev_eui;\nattributes.fPort = data.uplink_message.f_port;\n// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually\nattributes.correlation_ids = data.correlation_ids;\n\n// You can exclude some keys from the result\nvar excludeFromTelemetryList = [\"uplink_token\", \"gateway_id\", \"settings\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"network_ids\"];\nvar excludeFromAttributesList = [\"uplink_token\", \"gateway_id\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"session_key_id\", \"dev_eui\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.\nvar telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);\nvar attributesData = {};\nattributesData.putAll(toFlatMap(data.uplink_message.settings, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.end_device_ids, excludeFromAttributesList, false));\n\n// Passing incoming bytes to decodeFrmPayload function, to get custom decoding\nvar customDecoding = {};\nif (data.uplink_message.get(\"frm_payload\") != null) {\n  customDecoding = decodeFrmPayload(base64ToBytes(data.uplink_message.frm_payload));\n}\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: {\n        ts: timestamp,\n        values: telemetry\n    }\n};\n\nreturn result;",
      "encoder" : null,
      "tbelEncoder" : null,
      "updateOnlyKeys" : [ "devEui", "fPort", "bandwidth", "spreading_factor", "coding_rate", "frequency", "net_id", "tenant_id", "cluster_id", "cluster_address", "device_id", "application_id", "join_eui", "dev_addr", "battery", "pir", "daylight", "eui" ]
    },
    "debugMode" : true,
    "edgeTemplate" : false,
    "externalId" : null,
    "id" : {
      "entityType" : "CONVERTER",
      "id" : "22ea3a40-a60f-11ee-9b76-155fefa0fae7"
    },
    "name" : "Uplink data converter for TTN-nibiaa",
    "type" : "UPLINK"
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}